/* * PORTFOLIO TRACKER DATABASE SCHEMA
 * ---------------------------------------------------------
 * This script sets up the core tables, views, functions, and 
 * triggers required for the Portfolio Tracker application.
 */

-- =========================================================
-- 1. EXTENSIONS
-- =========================================================

-- Enable cron for scheduling updates
CREATE EXTENSION IF NOT EXISTS pg_cron;

-- Enable net for HTTP calls (Edge Functions)
CREATE EXTENSION IF NOT EXISTS pg_net;


-- =========================================================
-- 2. CORE TABLES
-- =========================================================

-- 1. PROFILES (The Managers)
-- Links directly to Supabase Auth Users
CREATE TABLE profiles (
    id UUID PRIMARY KEY REFERENCES auth.users ON DELETE CASCADE,
    username TEXT UNIQUE NOT NULL,
    full_name TEXT,
    email TEXT UNIQUE NOT NULL,
    screensaver_click_only BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- 2. CLIENTS (The Accounts)
-- Represents distinct portfolios or family members
CREATE TABLE clients (
    client_name TEXT PRIMARY KEY, -- Using name as PK as requested
    trading_id TEXT UNIQUE NOT NULL,
    client_id UUID UNIQUE DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
    last_verified TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- 3. ASSETS (The Master Catalog)
-- Stores market data and instrument details
CREATE TABLE assets (
    ticker TEXT PRIMARY KEY,
    stock_name TEXT NOT NULL,
    isin TEXT UNIQUE,
    current_price NUMERIC DEFAULT 0,
    last_updated TIMESTAMPTZ DEFAULT now()
);

-- 4. PURCHASES (The "In" Ledger)
-- Log of all buy transactions
CREATE TABLE purchases (
    trx_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES profiles(id) NOT NULL,
    client_name TEXT REFERENCES clients(client_name) ON DELETE CASCADE,
    ticker TEXT REFERENCES assets(ticker),
    date DATE NOT NULL,
    rate NUMERIC NOT NULL,
    qty NUMERIC NOT NULL CHECK (qty > 0),
    comments TEXT,
    sale_ids UUID[] DEFAULT '{}', -- Array to track partial sales linked to this purchase
    created_at TIMESTAMPTZ DEFAULT now()
);

-- 5. SALES (The "Out" Ledger)
-- Log of all sell transactions
CREATE TABLE sales (
    trx_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID,
    purchase_trx_id UUID REFERENCES purchases(trx_id) ON DELETE CASCADE,
    client_id UUID,
    client_name TEXT,
    date DATE NOT NULL,
    rate NUMERIC(20, 2) NOT NULL,
    sale_qty NUMERIC(20, 8) NOT NULL CHECK (sale_qty > 0),
    profit_stored NUMERIC,
    adjusted_profit_stored NUMERIC,
    long_term BOOLEAN,
    custom_id TEXT,
    comments TEXT,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- 6. PLEDGES (The Pledge Ledger)
-- Ledger for Pledging/Unpledging Transactions
CREATE TABLE pledges (
    client_name TEXT REFERENCES clients(client_name) ON DELETE CASCADE,
    ticker TEXT REFERENCES assets(ticker),
    pledged_qty NUMERIC NOT NULL CHECK (pledged_qty >= 0),
    created_at TIMESTAMPTZ DEFAULT now(),
    PRIMARY KEY (client_name, ticker) 
);


-- =========================================================
-- 3. INDEXES & SEQUENCES
-- =========================================================

-- Performance index for querying purchases by specific sale IDs (GIN index for Arrays)
CREATE INDEX IF NOT EXISTS idx_purchases_sale_ids ON purchases USING GIN (sale_ids);

-- Sequence for generating custom readable IDs if needed
CREATE SEQUENCE IF NOT EXISTS sale_group_seq START 1;


-- =========================================================
-- 4. VIEWS
-- =========================================================

-- View: CLIENT HOLDINGS
-- Calculates live balance, market value, and unrealized P&L
CREATE OR REPLACE VIEW client_holdings AS
SELECT 
    -- IDs and Identifiers
    p.trx_id,
    c.client_id,
    c.client_name,
    c.dp_id,
    c.trading_id,
    a.ticker,
    a.stock_name,
    a.isin,
    
    -- Purchase Details
    p.date,
    p.purchase_qty,
    p.rate,
    (p.purchase_qty * p.rate) AS purchase_value,
    p.balance_qty,
    p.comments,

    -- Market Details
    a.current_price AS market_rate,
    (p.balance_qty * a.current_price) AS market_value,

    -- Calculations
    (a.current_price - p.rate) AS pl_per_share,
    ((a.current_price - p.rate) * p.balance_qty) AS pl,
    CASE 
        WHEN p.rate > 0 THEN ((a.current_price - p.rate) / p.rate) * 100 
        ELSE 0 
    END AS pl_percent
FROM purchases p
JOIN assets a ON p.ticker = a.ticker
JOIN clients c ON p.client_name = c.client_name;

-- View: SALES VIEW
-- Denormalized view of sales with linked purchase info
CREATE OR REPLACE VIEW sales_view AS
SELECT 
    s.trx_id,
    c.client_id,
    c.trading_id,
    c.dp_id,
    s.client_name,
    p.ticker,
    a.stock_name,
    a.isin,
    p.date AS purchase_date,
    p.rate AS purchase_rate,
    p.trx_id as purchase_trx_id,
    p.purchase_qty,
    s.date AS sale_date,
    s.sale_qty,
    s.rate AS sale_rate,
    (s.sale_qty * p.rate) AS purchase_value,
    (s.sale_qty * s.rate) AS sale_value,
    s.profit_stored AS pl,
    ((s.profit_stored / p.rate) * 100) AS pl_percentage,
    s.adjusted_profit_stored AS adjusted_pl,
    s.long_term,
    s.comments,
    s.user_id,
    s.custom_id
FROM sales s
JOIN purchases p ON s.purchase_trx_id = p.trx_id
JOIN clients c ON p.client_name = c.client_name
JOIN assets a ON p.ticker = a.ticker;


-- =========================================================
-- 5. FUNCTIONS (BUSINESS LOGIC)
-- =========================================================

-- Function: Append Sale ID to Purchase
-- Updates the purchase record when a portion is sold
CREATE OR REPLACE FUNCTION append_sale_id_to_purchase(
    p_purchase_id UUID, 
    p_sale_id UUID, 
    p_new_balance NUMERIC
)
RETURNS void AS $$
BEGIN
    UPDATE purchases
    SET 
        balance_qty = p_new_balance,
        sale_ids = array_append(COALESCE(sale_ids, '{}'), p_sale_id)
    WHERE trx_id = p_purchase_id;
END;
$$ LANGUAGE plpgsql;

-- Function: Get Next Sale ID
-- Returns next value from sequence
CREATE OR REPLACE FUNCTION get_next_sale_id()
RETURNS BIGINT AS $$
BEGIN
  RETURN nextval('sale_group_seq');
END;
$$ LANGUAGE plpgsql;

-- Function: Atomic Ledger Update
-- Purpose: Handles complex transaction edits in a single transaction.
--          1. Deletes old sales (splits) if re-processing is needed.
--          2. Updates purchase records (balance, linkage, and core details).
--          3. Inserts new recalculated sale records.
-- Input:   JSONB object with optional keys: 'sales_to_delete', 'purchases_to_update', 'sales_to_insert'.

CREATE OR REPLACE FUNCTION atomic_ledger_update(payload JSONB)
RETURNS VOID AS $$
DECLARE
    p_record JSONB;
    s_record JSONB;
    id_to_delete TEXT;
BEGIN
    -- 1. DELETE Old Sales (Splits)
    -- Expects an array of 'custom_id' strings to remove entire sale batches.
    IF payload ? 'sales_to_delete' THEN
        FOR id_to_delete IN SELECT jsonb_array_elements_text(payload -> 'sales_to_delete')
        LOOP
            DELETE FROM sales WHERE custom_id = id_to_delete;
        END LOOP;
    END IF;

    -- 2. UPDATE Purchases
    -- Updates inventory balance/linkage AND core editable fields.
    IF payload ? 'purchases_to_update' THEN
        FOR p_record IN SELECT * FROM jsonb_array_elements(payload -> 'purchases_to_update')
        LOOP
            UPDATE purchases 
            SET 
                -- Inventory Management
                balance_qty = (p_record ->> 'balance_qty')::NUMERIC,
                sale_ids = ARRAY(SELECT jsonb_array_elements_text(p_record -> 'sale_ids')::UUID),
                
                -- Core Editable Fields
                date         = (p_record ->> 'date')::DATE,
                purchase_qty = (p_record ->> 'purchase_qty')::NUMERIC,
                rate         = (p_record ->> 'rate')::NUMERIC,
                comments     = (p_record ->> 'comments')
            WHERE trx_id = (p_record ->> 'trx_id')::UUID;
        END LOOP;
    END IF;

    -- 3. INSERT New Sales
    -- Inserts re-calculated sale splits.
    IF payload ? 'sales_to_insert' THEN
        INSERT INTO sales (
            trx_id, 
            custom_id, 
            purchase_trx_id, 
            client_name, 
            client_id,    
            date, 
            sale_qty, 
            rate, 
            profit_stored, 
            adjusted_profit_stored,
            long_term,
            user_id,
            comments
        )
        SELECT 
            (value ->> 'trx_id')::UUID,
            (value ->> 'custom_id'),
            (value ->> 'purchase_trx_id')::UUID,
            (value ->> 'client_name'),
            (value ->> 'client_id')::UUID,
            (value ->> 'date')::DATE,
            (value ->> 'sale_qty')::NUMERIC, 
            (value ->> 'rate')::NUMERIC,
            (value ->> 'profit_stored')::NUMERIC,
            (value ->> 'adjusted_profit_stored')::NUMERIC,
            (value ->> 'long_term')::BOOLEAN,
            (value ->> 'user_id')::UUID,
            (value ->> 'comments')
        FROM jsonb_array_elements(payload -> 'sales_to_insert');
    END IF;

    -- 4. UPDATE Existing Sales
    -- This handles re-calculating profit or updating details for specific sales
    IF payload ? 'sales_to_update' THEN
        FOR s_record IN SELECT * FROM jsonb_array_elements(payload -> 'sales_to_update')
        LOOP
            UPDATE sales 
            SET 
                profit_stored          = (s_record ->> 'profit_stored')::NUMERIC,
                adjusted_profit_stored = (s_record ->> 'adjusted_profit_stored')::NUMERIC,
                rate                   = (s_record ->> 'rate')::NUMERIC,
                sale_qty               = (s_record ->> 'sale_qty')::NUMERIC,
                date                   = (s_record ->> 'date')::DATE,
                comments               = (s_record ->> 'comments')
            WHERE trx_id = (s_record ->> 'trx_id')::UUID;
        END LOOP;
    END IF;
END;
$$ LANGUAGE plpgsql;

-- =========================================================
-- 6. TRIGGERS
-- =========================================================
-- Function & Trigger: Handle New User (Auth Hook)
-- Automatically creates Profile and Default Client entries on Signup
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger AS $$
BEGIN
  -- 1. Insert into Profiles
  INSERT INTO public.profiles (id, username, full_name, email)
  VALUES (
    new.id, 
    new.raw_user_meta_data->>'username', 
    new.raw_user_meta_data->>'full_name', 
    new.email
  );

  -- 2. Insert into Clients (Primary trading account)
  INSERT INTO public.clients (client_name, trading_id, user_id)
  VALUES (
    new.raw_user_meta_data->>'primary_client_name', 
    new.raw_user_meta_data->>'trading_id', 
    new.id
  );

  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();


-- =========================================================
-- 7. SCHEDULED JOBS (EDGE FUNCTIONS)
-- =========================================================

-- Schedule: Update Market Prices
-- Runs every 5 mins, between 3:30 and 10:30 UTC, Mon-Fri
SELECT cron.schedule(
  'update-market-prices-india-market', 
  '*/5 3-10 * * 1-5',                  
  $$
  SELECT
    net.http_post(
      url:='https://[YOUR_PROJECT_REF].functions.supabase.co/update-prices',
      headers:='{
        "Content-Type": "application/json", 
        "Authorization": "Bearer [YOUR_ANON_KEY]"
      }'::jsonb
    );
  $$
);