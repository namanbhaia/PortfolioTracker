Create Core Tables
-- 1. PROFILES (The Managers)
CREATE TABLE profiles (
    id UUID PRIMARY KEY REFERENCES auth.users ON DELETE CASCADE,
    username TEXT UNIQUE NOT NULL,
    full_name TEXT,
    email TEXT UNIQUE NOT NULL,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- 2. CLIENTS (The Accounts)
CREATE TABLE clients (
    client_name TEXT PRIMARY KEY, -- Using name as PK as requested
    trading_id TEXT UNIQUE NOT NULL,
    client_id UUID UNIQUE DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- 3. ASSETS (The Master Catalog)
CREATE TABLE assets (
    ticker TEXT PRIMARY KEY,
    stock_name TEXT NOT NULL,
    isin TEXT UNIQUE,
    current_price NUMERIC DEFAULT 0,
    last_updated TIMESTAMPTZ DEFAULT now()
);

-- 4. PURCHASES (The "In" Ledger)
CREATE TABLE purchases (
    trx_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES profiles(id) NOT NULL,
    client_name TEXT REFERENCES clients(client_name) ON DELETE CASCADE,
    ticker TEXT REFERENCES assets(ticker),
    date DATE NOT NULL,
    rate NUMERIC NOT NULL,
    qty NUMERIC NOT NULL CHECK (qty > 0),
    comments TEXT,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- 5. SALES (The "Out" Ledger)
CREATE TABLE sales (
    trx_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES profiles(id) NOT NULL,
    purchase_trx_id UUID REFERENCES purchases(trx_id) ON DELETE CASCADE,
    date DATE NOT NULL,
    rate NUMERIC NOT NULL,
    qty NUMERIC NOT NULL CHECK (qty > 0),
    comments TEXT,
    created_at TIMESTAMPTZ DEFAULT now()
);


Create Holding Views
CREATE OR REPLACE VIEW public.client_holdings AS
SELECT 
    -- 1. IDs and Identifiers
    p.trx_id,
    c.client_id,        -- Fetched from clients table via name link
    c.client_name,      -- The link itself
    c.dp_id,
    c.trading_id,
    a.ticker,
    a.stock_name,
    a.isin,
    
    -- 2. Purchase Details
    p.date,
    p.purchase_qty,
    p.rate,
    (p.purchase_qty * p.rate) AS purchase_value,
    p.balance_qty,
    p.comments,

    -- 3. Market Details
    a.current_price AS market_rate,
    (p.balance_qty * a.current_price) AS market_value,

    -- 4. Calculations
    (a.current_price - p.rate) AS pl_per_share,
    ((a.current_price - p.rate) * p.balance_qty) AS pl,
    CASE 
        WHEN p.rate > 0 
        THEN ((a.current_price - p.rate) / p.rate) * 100 
        ELSE 0 
    END AS pl_percent

FROM 
    public.purchases p
JOIN 
    public.assets a ON p.ticker = a.ticker
JOIN 
    public.clients c ON p.client_name = c.client_name; -- Linking via Name


Create Sales View
CREATE OR REPLACE VIEW sales_view AS
SELECT 
    s.trx_id,
    s.purchase_trx_id,
    c.client_id,
    c.trading_id,
    p.client_name, -- Pulled from the parent purchase record
    p.ticker,
    a.stock_name,
    a.isin,
    p.date AS purchase_date,
    p.qty AS purchase_qty,
    p.rate AS purchase_rate,
    (s.qty * p.rate) AS purchase_value, 
    s.date AS sale_date,
    s.qty AS sale_qty,
    s.rate AS sale_rate,
    (s.qty * s.rate) AS sale_value,
    ((s.rate - p.rate) * s.qty) AS profit,
    (s.date - p.date > 365) AS long_term,
    CASE 
        WHEN (s.date - p.date > 365) THEN ((s.rate - p.rate) * s.qty * 0.125) -- 12.5% LTCG
        ELSE ((s.rate - p.rate) * s.qty * 0.20) -- 20% STCG
    END AS tax_payable,
    s.comments,
    s.user_id
FROM sales s
JOIN purchases p ON s.purchase_trx_id = p.trx_id
JOIN clients c ON p.client_name = c.client_name
JOIN assets a ON p.ticker = a.ticker;

Key Safeguards
CREATE OR REPLACE FUNCTION check_sale_qty() 
RETURNS TRIGGER AS $$
DECLARE
    available_qty NUMERIC;
BEGIN
    SELECT balance_qty INTO available_qty 
    FROM client_holdings 
    WHERE trx_id = NEW.purchase_trx_id;

    IF NEW.qty > available_qty THEN
        RAISE EXCEPTION 'Cannot sell % units; only % available in this batch.', NEW.qty, available_qty;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER validate_sale_qty
BEFORE INSERT ON sales
FOR EACH ROW EXECUTE FUNCTION check_sale_qty();

For Login Setup
-- 1. Create the function that inserts a profile
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger AS $$
BEGIN
  INSERT INTO public.profiles (id, username, email)
  VALUES (new.id, new.raw_user_meta_data->>'username', new.email);
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to handle the sale transaction
-- Function to handle the sale transaction
CREATE OR REPLACE FUNCTION record_sale_transaction(
    sales_to_insert JSONB,
    purchases_to_update JSONB
)
RETURNS void AS $$
BEGIN
    -- Insert new sales records
    INSERT INTO sales (purchase_trx_id, user_id, date, rate, sale_qty, comments, long_term)
    SELECT
        (s->>'purchase_trx_id')::UUID,
        (s->>'user_id')::UUID,
        (s->>'date')::DATE,
        (s->>'rate')::NUMERIC,
        (s->>'sale_qty')::NUMERIC,
        s->>'comments',
        (s->>'long_term')::BOOLEAN
    FROM jsonb_array_elements(sales_to_insert) s;

    -- Update purchase balances
    UPDATE purchases p
    SET balance_qty = (u->>'balance_qty')::NUMERIC
    FROM jsonb_array_elements(purchases_to_update) u
    WHERE p.trx_id = (u->>'trx_id')::UUID;
END;
$$ LANGUAGE plpgsql;

-- 2. Create the trigger to run the function on every signup
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();


For Signup 
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger AS $$
BEGIN
  -- 1. Insert into Profiles
  INSERT INTO public.profiles (id, username, full_name, email)
  VALUES (
    new.id, 
    new.raw_user_meta_data->>'username', 
    new.raw_user_meta_data->>'full_name', 
    new.email
  );

  -- 2. Insert into Clients (Your first family member/trading account)
  INSERT INTO public.clients (client_name, trading_id, user_id)
  VALUES (
    new.raw_user_meta_data->>'primary_client_name', 
    new.raw_user_meta_data->>'trading_id', 
    new.id
  );

  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;