Create Core Tables
-- 1. PROFILES (The Managers)
CREATE TABLE profiles (
    id UUID PRIMARY KEY REFERENCES auth.users ON DELETE CASCADE,
    username TEXT UNIQUE NOT NULL,
    full_name TEXT,
    email TEXT UNIQUE NOT NULL,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- 2. CLIENTS (The Accounts)
CREATE TABLE clients (
    client_name TEXT PRIMARY KEY, -- Using name as PK as requested
    trading_id TEXT UNIQUE NOT NULL,
    client_id UUID UNIQUE DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT now()
);
ALTER TABLE clients 
ADD COLUMN last_verified TIMESTAMPTZ;

-- 3. ASSETS (The Master Catalog)
CREATE TABLE assets (
    ticker TEXT PRIMARY KEY,
    stock_name TEXT NOT NULL,
    isin TEXT UNIQUE,
    current_price NUMERIC DEFAULT 0,
    last_updated TIMESTAMPTZ DEFAULT now()
);

-- 4. PURCHASES (The "In" Ledger)
CREATE TABLE purchases (
    trx_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES profiles(id) NOT NULL,
    client_name TEXT REFERENCES clients(client_name) ON DELETE CASCADE,
    ticker TEXT REFERENCES assets(ticker),
    date DATE NOT NULL,
    rate NUMERIC NOT NULL,
    qty NUMERIC NOT NULL CHECK (qty > 0),
    comments TEXT,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- Add the sale_ids column as an array of UUIDs to the purchases table
ALTER TABLE purchases 
ADD COLUMN IF NOT EXISTS sale_ids UUID[] DEFAULT '{}';

-- Optional: Add an index for performance if you plan to query by sale_id often
CREATE INDEX IF NOT EXISTS idx_purchases_sale_ids ON purchases USING GIN (sale_ids);

-- 5. SALES (The "Out" Ledger)
create table public.sales (
  trx_id uuid not null default gen_random_uuid (),
  user_id uuid null,
  purchase_trx_id uuid null,
  date date not null,
  rate numeric(20, 2) not null,
  sale_qty numeric(20, 8) not null,
  comments text null,
  created_at timestamp with time zone null default now(),
  long_term boolean null,
  custom_id text null,
  client_name text null,
  profit_stored numeric null,
  client_id uuid null,
  constraint sales_pkey primary key (trx_id),
  constraint sales_purchase_trx_id_fkey foreign KEY (purchase_trx_id) references purchases (trx_id) on delete CASCADE,
  constraint sales_qty_check check ((sale_qty > (0)::numeric))
) TABLESPACE pg_default;

ALTER TABLE sales ADD COLUMN IF NOT EXISTS adjusted_profit_stored NUMERIC;

CREATE OR REPLACE FUNCTION append_sale_id_to_purchase(
    p_purchase_id UUID, 
    p_sale_id UUID, 
    p_new_balance NUMERIC
)
RETURNS void AS $$
BEGIN
    UPDATE purchases
    SET 
        balance_qty = p_new_balance,
        sale_ids = array_append(COALESCE(sale_ids, '{}'), p_sale_id)
    WHERE trx_id = p_purchase_id;
END;
$$ LANGUAGE plpgsql;

-- 1. Create a sequence if it doesn't exist
CREATE SEQUENCE IF NOT EXISTS sale_group_seq START 1;

-- 2. Create the RPC function with the correct return type (BIGINT)
CREATE OR REPLACE FUNCTION get_next_sale_id()
RETURNS BIGINT AS $$
BEGIN
  RETURN nextval('sale_group_seq');
END;
$$ LANGUAGE plpgsql;

create trigger validate_sale_qty BEFORE INSERT on sales for EACH row
execute FUNCTION check_sale_qty ();

Create Holding Views
CREATE OR REPLACE VIEW public.client_holdings AS
SELECT 
    -- 1. IDs and Identifiers
    p.trx_id,
    c.client_id,        -- Fetched from clients table via name link
    c.client_name,      -- The link itself
    c.dp_id,
    c.trading_id,
    a.ticker,
    a.stock_name,
    a.isin,
    
    -- 2. Purchase Details
    p.date,
    p.purchase_qty,
    p.rate,
    (p.purchase_qty * p.rate) AS purchase_value,
    p.balance_qty,
    p.comments,

    -- 3. Market Details
    a.current_price AS market_rate,
    (p.balance_qty * a.current_price) AS market_value,

    -- 4. Calculations
    (a.current_price - p.rate) AS pl_per_share,
    ((a.current_price - p.rate) * p.balance_qty) AS pl,
    CASE 
        WHEN p.rate > 0 
        THEN ((a.current_price - p.rate) / p.rate) * 100 
        ELSE 0 
    END AS pl_percent

FROM 
    public.purchases p
JOIN 
    public.assets a ON p.ticker = a.ticker
JOIN 
    public.clients c ON p.client_name = c.client_name; -- Linking via Name


Create Sales View
DROP VIEW IF EXISTS sales_view CASCADE;

CREATE OR REPLACE VIEW sales_view AS
SELECT 
    s.trx_id,
    c.client_id,
    c.trading_id,
    c.dp_id, -- New column
    s.client_name,
    p.ticker,
    a.stock_name,
    a.isin,
    p.date AS purchase_date,
    p.rate AS purchase_rate,
    p.trx_id as purchase_trx_id,
    p.purchase_qty,
    s.date AS sale_date,
    s.sale_qty,
    s.rate AS sale_rate,
    (s.sale_qty * p.rate) AS purchase_value,
    (s.sale_qty * s.rate) AS sale_value,
    s.profit_stored AS pl,
    ((s.profit_stored / p.rate) * 100) AS pl_percentage,
    s.adjusted_profit_stored AS adjusted_pl,
    s.long_term,
    s.comments,
    s.user_id,
    s.custom_id
FROM sales s
JOIN purchases p ON s.purchase_trx_id = p.trx_id
JOIN clients c ON p.client_name = c.client_name
JOIN assets a ON p.ticker = a.ticker;


Key Safeguards
CREATE OR REPLACE FUNCTION check_sale_qty() 
RETURNS TRIGGER AS $$
DECLARE
    available_qty NUMERIC;
BEGIN
    SELECT balance_qty INTO available_qty 
    FROM client_holdings 
    WHERE trx_id = NEW.purchase_trx_id;

    IF NEW.qty > available_qty THEN
        RAISE EXCEPTION 'Cannot sell % units; only % available in this batch.', NEW.qty, available_qty;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER validate_sale_qty
BEFORE INSERT ON sales
FOR EACH ROW EXECUTE FUNCTION check_sale_qty();

For Login Setup
-- 1. Create the function that inserts a profile
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger AS $$
BEGIN
  INSERT INTO public.profiles (id, username, email)
  VALUES (new.id, new.raw_user_meta_data->>'username', new.email);
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 2. Create the trigger to run the function on every signup
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();


For Signup 
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger AS $$
BEGIN
  -- 1. Insert into Profiles
  INSERT INTO public.profiles (id, username, full_name, email)
  VALUES (
    new.id, 
    new.raw_user_meta_data->>'username', 
    new.raw_user_meta_data->>'full_name', 
    new.email
  );

  -- 2. Insert into Clients (Your first family member/trading account)
  INSERT INTO public.clients (client_name, trading_id, user_id)
  VALUES (
    new.raw_user_meta_data->>'primary_client_name', 
    new.raw_user_meta_data->>'trading_id', 
    new.id
  );

  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


For edge function
-- Enable the cron extension
create extension if not exists pg_cron;

-- Enable the net extension (to allow the DB to make HTTP calls to the Edge Function)
create extension if not exists pg_net;

SELECT cron.schedule(
  'update-market-prices-india-market', -- Unique Job Name
  '*/5 3-10 * * 1-5',                  -- Every 5 mins, between 3:30 and 10:30 UTC, Mon-Fri
  $$
  SELECT
    net.http_post(
      url:='https://[YOUR_PROJECT_REF].functions.supabase.co/update-prices',
      headers:='{
        "Content-Type": "application/json", 
        "Authorization": "Bearer [YOUR_ANON_KEY]"
      }'::jsonb
    );
  $$
);

-- Check the last 10 runs to see if they were successful
SELECT * FROM cron.job_run_details 
ORDER BY start_time DESC 
LIMIT 10;

-- Enable the pg_net extension if not already (usually standard)
-- Create a type for structure if strictly typed, or just use JSONB

CREATE OR REPLACE FUNCTION atomic_ledger_update(payload JSONB)
RETURNS VOID AS $$
DECLARE
    p_record JSONB;
    s_record JSONB;
    id_to_delete TEXT;
BEGIN
    -- 1. DELETE "Invalidated" Sales (Splits)
    -- Expecting payload -> 'sales_to_delete' (array of custom_ids or trx_ids)
    IF payload ? 'sales_to_delete' THEN
        FOR id_to_delete IN SELECT jsonb_array_elements_text(payload -> 'sales_to_delete')
        LOOP
            -- Deleting by custom_id removes all splits associated with that user action
            DELETE FROM sales WHERE custom_id = id_to_delete;
        END LOOP;
    END IF;

    -- 2. UPDATE Purchases (Balance & Linkages)
    -- Expecting payload -> 'purchases_to_update' (array of objects)
    IF payload ? 'purchases_to_update' THEN
        FOR p_record IN SELECT * FROM jsonb_array_elements(payload -> 'purchases_to_update')
        LOOP
            UPDATE purchases 
            SET 
                balance_qty = (p_record ->> 'balance_qty')::NUMERIC,
                -- Assumes you added the sale_ids vector/array column
                sale_ids = ARRAY(SELECT jsonb_array_elements_text(p_record -> 'sale_ids'))
            WHERE trx_id = (p_record ->> 'trx_id')::UUID;
        END LOOP;
    END IF;

    -- 3. INSERT New Sales (Remapped Splits)
    -- Expecting payload -> 'sales_to_insert' (array of objects)
    IF payload ? 'sales_to_insert' THEN
        INSERT INTO sales (
            custom_id, 
            purchase_trx_id, 
            client_name, 
            ticker, 
            date, 
            qty, 
            rate, 
            profit_stored, 
            adjusted_profit_stored,
            user_id
        )
        SELECT 
            (value ->> 'custom_id'),
            (value ->> 'purchase_trx_id')::UUID,
            (value ->> 'client_name'),
            (value ->> 'ticker'),
            (value ->> 'date')::DATE,
            (value ->> 'qty')::NUMERIC,
            (value ->> 'rate')::NUMERIC,
            (value ->> 'profit_stored')::NUMERIC,
            (value ->> 'adjusted_profit_stored')::NUMERIC,
            (value ->> 'user_id')::UUID
        FROM jsonb_array_elements(payload -> 'sales_to_insert');
    END IF;
END;
$$ LANGUAGE plpgsql;