Create Core Tables
-- 1. PROFILES (The Managers)
CREATE TABLE profiles (
    id UUID PRIMARY KEY REFERENCES auth.users ON DELETE CASCADE,
    username TEXT UNIQUE NOT NULL,
    full_name TEXT,
    email TEXT UNIQUE NOT NULL,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- 2. CLIENTS (The Accounts)
CREATE TABLE clients (
    client_name TEXT PRIMARY KEY, -- Using name as PK as requested
    trading_id TEXT UNIQUE NOT NULL,
    client_id UUID UNIQUE DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- 3. ASSETS (The Master Catalog)
CREATE TABLE assets (
    ticker TEXT PRIMARY KEY,
    stock_name TEXT NOT NULL,
    isin TEXT UNIQUE,
    current_price NUMERIC DEFAULT 0,
    last_updated TIMESTAMPTZ DEFAULT now()
);

-- 4. PURCHASES (The "In" Ledger)
CREATE TABLE purchases (
    trx_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES profiles(id) NOT NULL,
    client_name TEXT REFERENCES clients(client_name) ON DELETE CASCADE,
    ticker TEXT REFERENCES assets(ticker),
    date DATE NOT NULL,
    rate NUMERIC NOT NULL,
    qty NUMERIC NOT NULL CHECK (qty > 0),
    comments TEXT,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- Add the sale_ids column as an array of UUIDs to the purchases table
ALTER TABLE purchases 
ADD COLUMN IF NOT EXISTS sale_ids UUID[] DEFAULT '{}';

-- Optional: Add an index for performance if you plan to query by sale_id often
CREATE INDEX IF NOT EXISTS idx_purchases_sale_ids ON purchases USING GIN (sale_ids);

-- 5. SALES (The "Out" Ledger)
create table public.sales (
  trx_id uuid not null default gen_random_uuid (),
  user_id uuid null,
  purchase_trx_id uuid null,
  date date not null,
  rate numeric(20, 2) not null,
  sale_qty numeric(20, 8) not null,
  comments text null,
  created_at timestamp with time zone null default now(),
  long_term boolean null,
  custom_id text null,
  client_name text null,
  profit_stored numeric null,
  client_id uuid null,
  constraint sales_pkey primary key (trx_id),
  constraint sales_purchase_trx_id_fkey foreign KEY (purchase_trx_id) references purchases (trx_id) on delete CASCADE,
  constraint sales_qty_check check ((sale_qty > (0)::numeric))
) TABLESPACE pg_default;

ALTER TABLE sales ADD COLUMN IF NOT EXISTS adjusted_profit_stored NUMERIC;

CREATE OR REPLACE FUNCTION append_sale_id_to_purchase(
    p_purchase_id UUID, 
    p_sale_id UUID, 
    p_new_balance NUMERIC
)
RETURNS void AS $$
BEGIN
    UPDATE purchases
    SET 
        balance_qty = p_new_balance,
        sale_ids = array_append(COALESCE(sale_ids, '{}'), p_sale_id)
    WHERE trx_id = p_purchase_id;
END;
$$ LANGUAGE plpgsql;

-- 1. Create a sequence if it doesn't exist
CREATE SEQUENCE IF NOT EXISTS sale_group_seq START 1;

-- 2. Create the RPC function with the correct return type (BIGINT)
CREATE OR REPLACE FUNCTION get_next_sale_id()
RETURNS BIGINT AS $$
BEGIN
  RETURN nextval('sale_group_seq');
END;
$$ LANGUAGE plpgsql;

create trigger validate_sale_qty BEFORE INSERT on sales for EACH row
execute FUNCTION check_sale_qty ();

Create Holding Views
CREATE OR REPLACE VIEW public.client_holdings AS
SELECT 
    -- 1. IDs and Identifiers
    p.trx_id,
    c.client_id,        -- Fetched from clients table via name link
    c.client_name,      -- The link itself
    c.dp_id,
    c.trading_id,
    a.ticker,
    a.stock_name,
    a.isin,
    
    -- 2. Purchase Details
    p.date,
    p.purchase_qty,
    p.rate,
    (p.purchase_qty * p.rate) AS purchase_value,
    p.balance_qty,
    p.comments,

    -- 3. Market Details
    a.current_price AS market_rate,
    (p.balance_qty * a.current_price) AS market_value,

    -- 4. Calculations
    (a.current_price - p.rate) AS pl_per_share,
    ((a.current_price - p.rate) * p.balance_qty) AS pl,
    CASE 
        WHEN p.rate > 0 
        THEN ((a.current_price - p.rate) / p.rate) * 100 
        ELSE 0 
    END AS pl_percent

FROM 
    public.purchases p
JOIN 
    public.assets a ON p.ticker = a.ticker
JOIN 
    public.clients c ON p.client_name = c.client_name; -- Linking via Name


Create Sales View
CREATE OR REPLACE VIEW sales_view AS
SELECT 
    s.custom_id,                        -- Your self-generated ID
    c.trading_id,                       --
    s.client_name,                      --
    p.ticker,                           --
    a.stock_name,                       --
    a.isin,                             --
    p.date AS purchase_date,            --
    p.purchase_qty AS purchase_qty,     -- Corrected column name for Purchases table
    p.rate AS purchase_rate,            --
    (s.sale_qty * p.rate) AS purchase_value, -- Value of the specific portion sold
    s.date AS sale_date,                --
    s.sale_qty AS sale_qty,             -- Corrected column name for Sales table
    s.rate AS sale_rate,                --
    (s.sale_qty * s.rate) AS sale_value, -- Total value of the sale
    ((s.rate - p.rate) * s.sale_qty) AS profit, -- Realized profit calculation
    (s.date::DATE - p.date::DATE > 365) AS long_term, -- Fixed date-text operator error
    s.comments,                         --
    s.user_id                            -- Required for app/dashboard/sales/page.tsx filtering
FROM sales s
JOIN purchases p ON s.purchase_trx_id = p.trx_id
JOIN clients c ON p.client_name = c.client_name
JOIN assets a ON p.ticker = a.ticker;
s
Key Safeguards
CREATE OR REPLACE FUNCTION check_sale_qty() 
RETURNS TRIGGER AS $$
DECLARE
    available_qty NUMERIC;
BEGIN
    SELECT balance_qty INTO available_qty 
    FROM client_holdings 
    WHERE trx_id = NEW.purchase_trx_id;

    IF NEW.qty > available_qty THEN
        RAISE EXCEPTION 'Cannot sell % units; only % available in this batch.', NEW.qty, available_qty;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER validate_sale_qty
BEFORE INSERT ON sales
FOR EACH ROW EXECUTE FUNCTION check_sale_qty();

For Login Setup
-- 1. Create the function that inserts a profile
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger AS $$
BEGIN
  INSERT INTO public.profiles (id, username, email)
  VALUES (new.id, new.raw_user_meta_data->>'username', new.email);
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 2. Create the trigger to run the function on every signup
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();


For Signup 
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger AS $$
BEGIN
  -- 1. Insert into Profiles
  INSERT INTO public.profiles (id, username, full_name, email)
  VALUES (
    new.id, 
    new.raw_user_meta_data->>'username', 
    new.raw_user_meta_data->>'full_name', 
    new.email
  );

  -- 2. Insert into Clients (Your first family member/trading account)
  INSERT INTO public.clients (client_name, trading_id, user_id)
  VALUES (
    new.raw_user_meta_data->>'primary_client_name', 
    new.raw_user_meta_data->>'trading_id', 
    new.id
  );

  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;